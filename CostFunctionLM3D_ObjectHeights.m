function [F,J] = CostFunctionLM3D_ObjectHeights(params,h,cy,mu,sigma,Hy,fhat,py,sigma_N)
% Inputs:
% params - Camera parameters to optimize
% h - 1xN object heights (in pixels)
% cy - 1xN y-coordinate of contact point
% mu - 1xN mean of real-world object height (in centimeters)
% sigma - 1xN std dev of real-world object height (in centimeters)
% f - Focal length
% py - Y coordinate of principal point
% sigma_N - std dev of pixel labeling error

% Hyper-parameters:
lambda_f = 0.1; % Regularization weight for focal length
Cy_mean = 170;
Cy_std = 50;

% Get parameters to optimize:
Cy = params(1); % Camera height
t = params(2); % Camera pitch angle
f = params(3); % Focal length

% Get y-coordinate of horizon line:
vy = py-f*tan(t);

% Number of objects
N = length(h);

F = []; J = [];

if length(h) > 0
  % Height error (in pixels), weighted by uncertainty in real-world
  % object height and labeling error (in pixels):
  w = 1./(sigma.*(vy-cy)./Cy + sigma_N); % Standard deviation
  F = w.*(mu.*(vy-cy)./Cy - h);
  J = Jacobian_ObjectHeights(Cy,t,f,py,h,cy,mu,sigma,sigma_N)';
end

if length(Hy) > 0
  Hy = mean(Hy,1);
  
  Nv = length(Hy);
  
  % Horizon line error (in pixels), weighted by labeling error (in pixels):
  F = [F (vy-Hy)/sigma_N];
  J = [J; [zeros(Nv,1) -f*(tan(t)^2+1)/sigma_N*ones(Nv,1) -tan(t)/sigma_N*ones(Nv,1)]];
end

% Regularization on camera height:
F(end+1) = (Cy-Cy_mean)/Cy_std;
J(end+1,:) = [1/Cy_std 0 0];

% Regularization on focal length:
F(end+1) = lambda_f*(f-fhat);
J(end+1,:) = [0 0 lambda_f];

return;

function J = Jacobian_ObjectHeights(Cy,t,f,py,h,cy,mu,sigma,sigma_N)
%    This function was generated by the Symbolic Math Toolbox version 5.2.
%    13-Feb-2013 11:39:27

t2 = tan(t);
t3 = f.*t2;
t4 = cy - py + t3;
t5 = 1./Cy.^2;
t6 = 1./Cy;
t8 = sigma.*t4.*t6;
t7 = sigma_N - t8;
t9 = 1./t7;
t10 = mu.*t4.*t6;
t11 = h + t10;
t12 = 1./t7.^2;
t13 = t2.^2;
t14 = t13 + 1;
J = [mu.*t4.*t5.*t9 + sigma.*t11.*t12.*t4.*t5;- f.*mu.*t14.*t6.*t9 - f.*sigma.*t11.*t12.*t14.*t6;- mu.*t2.*t6.*t9 - sigma.*t11.*t12.*t2.*t6];

return;



% $$$ % Derivation for Jacobian_ObjectHeights
% $$$ 
% $$$ % Camera parameters:
% $$$ syms f px py
% $$$ syms Cy t;
% $$$ 
% $$$ % Data:
% $$$ syms h cy mu sigma sigma_N
% $$$ 
% $$$ % Get camera calibration matrix:
% $$$ K = [f 0 px; 0 f py; 0 0 1];
% $$$ 
% $$$ % Camera rotation (assume rotation through X axis):
% $$$ N = [0 0 0; 0 0 -1; 0 1 0];
% $$$ R = eye(3) + sin(t)*N + (1-cos(t))*N*N;
% $$$ 
% $$$ % Get camera center:
% $$$ C = [0; Cy; 0];
% $$$ 
% $$$ % Get camera matrix:
% $$$ P = K*R*[eye(3) -C];
% $$$ 
% $$$ % Get horizon line:
% $$$ hl = cross(P(:,1),P(:,3));
% $$$ 
% $$$ % Get y-coordinate of horizon line:
% $$$ Hy = cross(hl,cross([1 1 1],[1 2 1])); % Intersect vertical line with horizon
% $$$ Hy = Hy(2)/Hy(3);
% $$$ 
% $$$ Hy = py-f*tan(t); % This is resulting Y coordinate
% $$$ 
% $$$ % Height error, weighted by uncertainty in object height and labeling error:
% $$$ w = 1./(sigma.*(Hy-cy)./Cy+sigma_N); % Standard deviation
% $$$ F = w*(mu.*(Hy-cy)./Cy - h);
% $$$ 
% $$$ % Jacobian:
% $$$ J = [diff(F,'Cy'); diff(F,'t'); diff(F,'f')];
% $$$ 
% $$$ matlabFunction(J,'file','Jacobian_ObjectHeights.m');
